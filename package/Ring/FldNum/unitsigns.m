freeze;

// Sign functions for orders.

h:= func< x | x eq 1 select 0 else 1 >;
intrinsic UnitsWithSigns(O::RngOrd[RngInt], oo::[PlcNumElt], Signs::[RngIntElt]) -> SeqEnum
{Computes all units in O modulo squares such that the sign of the i-th real place in oo equals Signs[i]}
  require #oo eq #Signs : "Wrong number of signs";
  require Set(Signs) subset {-1,1}: "Signs must be either 1 or -1";
  require #oo eq 0 or NumberField(oo[1]) cmpeq NumberField(O) : "Wrong infinite places";
  require forall{ inf: inf in oo | IsReal(inf) }: "The places must be real";
  U, f:= UnitGroup(O);
  U:= [ f(U.i): i in [1..Ngens(U)] ];
  M:= Matrix(GF(2), #oo, #U, [ [ h(Sign(Evaluate(u,inf))): inf in oo ] : u in U ] );
  s:= Vector(GF(2), [ h(s): s in Signs ]);
  ok, x, KK:= IsConsistent(M, s);
  if not ok then return [O | ]; end if;
  return [ O | PowerProduct(U, ChangeUniverse(Eltseq(x+b), Integers())) : b in KK ];
end intrinsic;

intrinsic UnitsWithSigns(K::FldAlg, oo::[PlcNumElt], Signs::[RngIntElt]) -> SeqEnum
{"}//"
  require #oo eq #Signs : "Wrong number of signs";
  require Set(Signs) subset {-1,1}: "Signs must be either 1 or -1";
  require #oo eq 0 or NumberField(oo[1]) cmpeq K : "Wrong infinite places";
  require forall{ inf: inf in oo | IsReal(inf) }: "The places must be real";
  return ChangeUniverse(UnitsWithSigns( Integers(K), oo, Signs ), K);
end intrinsic;

intrinsic UnitsWithSigns(O::RngInt, oo::[Infty], Signs::[RngIntElt]) -> SeqEnum
{"}//"
  require #oo eq #Signs: "Wrong number of signs"; 
  require Set(Signs) subset {-1,1}: "Signs must be either 1 or -1";
  if   #Set(Signs) gt 1 then return [O | ];
  elif #Set(Signs) eq 0 then return [1,-1];
  else return Signs[1..1];
  end if;
end intrinsic;

intrinsic UnitsWithSigns(K::FldRat, oo::[Infty], Signs::[RngIntElt]) -> SeqEnum
{"}//"
  require #oo eq #Signs: "Wrong number of signs";
  require Set(Signs) subset {-1,1}: "Signs must be either 1 or -1";
  return ChangeUniverse(UnitsWithSigns(Integers(), oo, Signs), K);
end intrinsic;

// Same signs as an element
intrinsic UnitsWithSigns(O::RngOrd[RngInt], x::RngElt) -> BoolElt, SeqEnum
{Computes all units in O modulo squares that have the same signs as x at all real places of O}
  K:= NumberField(O);
  ok, x:= IsCoercible(K, x);
  require ok: "The element must lie in the number field of the order";
  require x ne 0: "The element must be nonzero";
  return UnitsWithSigns( O, RealPlaces(K), Signature(x) );
end intrinsic;

intrinsic UnitsWithSigns(K::FldAlg, x::RngElt) -> SeqEnum
{"}//"
  ok, x:= IsCoercible(K, x);
  require ok: "The element must lie in the field";
  require x ne 0: "The element must be nonzero";
  return UnitsWithSigns( K, RealPlaces(K), Signature(x) );
end intrinsic;

intrinsic UnitsWithSigns(O::RngInt, x::RngElt) -> SeqEnum
{"}//"
  ok, x:= IsCoercible(Rationals(), x);
  require ok: "The element must lie in the rationals";
  require x ne 0: "The element must be nonzero";
  return [ Sign(x) ];
end intrinsic;

intrinsic UnitsWithSigns(K::FldRat, x::RngElt) -> SeqEnum
{"}//"
  ok, x:= IsCoercible(K, x);
  require ok: "The element must lie in the rationals";
  require x ne 0: "The element must be nonzero";
  return [ K | Sign(x) ];
end intrinsic;

// K and O omitted
intrinsic UnitsWithSigns(x::RngOrdElt[RngInt]) -> SeqEnum
{Given an element x in an order or number field O, computes all units of 
 O modulo squares that have the same signs as x at all real places of O}
  require x ne 0 : "The element must be nonzero";
  K:= NumberField(Parent(x));
  return UnitsWithSigns( Parent(x), RealPlaces(K), Signature(K!x) );
end intrinsic;

intrinsic UnitsWithSigns(x::FldAlgElt) -> SeqEnum
{"}//"
  require x ne 0: "The element must be nonzero";
  K:= Parent(x);
  return UnitsWithSigns( K, RealPlaces(K), Signature(x) );
end intrinsic;

intrinsic UnitsWithSigns(x::FldRatElt) -> SeqEnum
{"}//"
  require x ne 0: "The element must be nonzero";
  return [ Rationals() | Sign(x) ];
end intrinsic;

intrinsic UnitsWithSigns(x::RngIntElt) -> SeqEnum
{"}//"
  require x ne 0: "The element must be nonzero";
  return [ Sign(x) ];
end intrinsic;


// Totally positive ideal generators

intrinsic HasTotallyPositiveGenerator(I::RngOrdFracIdl) -> BoolElt, []
{Check if I can be generated by some totally positive element. If so, the 
 second return value is the list of all such generators modulo unit squares}

 ok, x:= IsPrincipal(I);
 if not ok then return false, []; end if;
 U:= UnitsWithSigns(Order(I), x);
 return #U ne 0, [ x * u : u in U ];
end intrinsic;
